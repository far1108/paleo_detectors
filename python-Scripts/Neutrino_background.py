# calculate recoil rate induced by neutrino-background for one sort of nuclei in a mineral
# results saved in "Data/Neutrino_background/Recoil_rates"

import numpy as np
import matplotlib.pyplot as plt

c_light = 3E+08
hbar = 1.055E-34
u = 931.5E6*1.6E-19/c_light**2 # atomic mass unit in kg
##########################################################################################

# atomic number, mass number and mass in kg of considered recoiling nucleus
Z = 1
A = 1
M = 1.008*u
N=A-Z # number of neutrons in nucleus

# txt-file which consists of three columns (as generated by SRModule):
# recoil energy (keV), stopping power due to energy loss to target electrons (eV/Angstrom), stopping power due to energy loss to target nuclei (eV/Angstrom)
ER,dEdx_el,dEdx_nucl = np.loadtxt('SRIM-table-file',unpack=True)
ER = ER*1.6E-16 #recoil energy in J
dEdx = (dEdx_el+dEdx_nucl)*1.6E-9 # corresponding stopping power in J/m
ldata = len(ER)

# integrated neutrino-flux values for each recoil energy (as generated by "Neutrino_flux_integration.py")
Phi_int = np.loadtxt('nu-flux.txt')
Phi_d_E_int = np.loadtxt('nudEnu2.txt')

############################################################################################
GF = 4.5437957E14*(hbar*c_light)**3 # Fermi coupling constant in 1/J^2
sin2ThetaW = 0.2223 # sine squared of weak mixing angle
QW = N-(1-4*sin2ThetaW)*Z # weak nuclear hypercharge

############################################################################################
# Helm form factor

# needed parameters (in fm)
s = 0.9
a = 0.52
c = (1.23*A**(1/3)-0.6)
R_1 = np.sqrt(c**2+7/3*np.pi**2*a**2-5*s**2)

# spherical Bessel function
def j_1(x):
    return np.sin(x)/x**2-np.cos(x)/x

# calculate momentum transfer in 1/fm depending on recoil energy in J
def q(E):
    return np.sqrt(2*(M/1.6E-10*c_light**2)*(E/1.6E-16)*10**(-6))/0.197

# calculate Helm form factor |F^2(q)| depending on momentum transfer in 1/fm
def F2(q):
    return (3*j_1(q*R_1)/(q*R_1))**2*np.exp(-q**2*s**2)

###########################################################################################################

# compute differential recoil rate per unit target mass for every considered recoil energy
dRdE = np.zeros(ldata)
for i in range(ldata):
	dRdE[i] = GF**2/(4*np.pi)*QW**2*M*c_light**2*F2(q(ER[i]))/(hbar*c_light)**4*(Phi_int[i]-M*c_light**2*ER[i]/2*Phi_d_E_int[i])/M

# save recoil rate depending on the track length in 1/(kg*s*m)
# the corresponding track lengths are the same as obtained from "Tracklength_spectrum.py"
np.savetxt('nu-spectrum.txt',dRdE*dEdx)
